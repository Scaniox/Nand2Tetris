// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/12/Screen.jack

/**
 * A library of functions for displaying graphics on the screen.
 * The Hack physical screen consists of 512 rows (indexed 0..511, top to bottom)
 * of 256 pixels each (indexed 0..255, left to right). The top left pixel on
 * the screen is indexed (0,0).
 */
class Screen {
    static bool color;


    function void break(){
        return;
    }

    /** Initializes the Screen. */
    function void init() {
        let color = true;
        return;
    }

    /** Sets the current color, to be used for all subsequent drawXXX commands.
     *  Black is represented by true, white by false. */
    function void setColor(boolean b) {
        let color = b;
        return;
    }

    /** Draws the (x,y) pixel, using the current color. */
    function void drawPixel(int x, int y) {
        var int address, word, remainder;

        let address = 16384 + (x / 16) + (y * 32); // find word in memory that holds correct pixel
        let word = Memory.peek(address);

        let remainder = x - ((x/16)*16);   // calculate which bit of the word the pixel is in
        if(color){
            let word = word | Math.poweroftwo(remainder);
        }
        else{
            let word = word & ~(Math.poweroftwo(remainder));
        }
        do Memory.poke(address, word);
        return;
    }

    /** Draws a line from pixel (x1,y1) to pixel (x2,y2), using the current color. */
    function void drawLine(int x1, int y1, int x2, int y2) {
        var int x_inc, y_inc, dx, dy, error;

        if(x1 = x2){ // vertical line
            if(y2 > y1){
                do Screen.draw_v_line(x1, y1, y2);
            }
            else{
                do Screen.draw_v_line(x1, y2, y1);
            }
            return;
        }

        if(y1 = y2){ // horizontal line
            if(x2 > x1){
                do Screen.draw_h_line(x1, y1, x2);
            }
            else{
                do Screen.draw_h_line(x2, y1, x1);
            }
            return;
        }

        // angled line
        let x_inc = 1;
        let y_inc = 1;
        let dx = Math.abs(x1-x2);
        let dy = Math.abs(y1-y2);
        if(x1 > x2){
            let x_inc = -1;
        }
        if(y1 > y2){
            let y_inc = -1;
        }

        if(dx > dy){ // increment x
            let error = dy + dy - dx;

            while(~(x1 = x2)){
                do Screen.drawPixel(x1, y1);
                let x1 = x1 + x_inc;

                if(error > 0){
                    let error = error - (dx + dx);
                    let y1 = y1 + y_inc;
                }
                let error = error + (dy + dy);
            }
        }
        else{ // increment y
            let error = dx + dx - dy;

            while(~(y1 = y2)){
                do Screen.drawPixel(x1, y1);
                let y1 = y1 + y_inc;

                if(error > 0){ // error has got big enough to overflow
                    let error = error - (dy + dy);
                    let x1 = x1 + x_inc;
                }
                let error = error + (dx + dx);
            }
        }
        do Screen.drawPixel(x2, y2);

        return;
    }

    function void draw_v_line(int x, int y1, int y2){
        var int address, mask;

        let address = 16384 + (x / 16) + (y1 * 32);
        let mask = Math.poweroftwo(x - ((x / 16) * 16));
        if(color){
            while(y1 < y2){
                do Memory.poke(address, Memory.peek(address) | mask);
                let y1 = y1 + 1;
                let address = address + 32;
            }
        }
        else{
            while(y1 < y2){
                do Memory.poke(address, Memory.peek(address) & ~mask);
                let y1 = y1 + 1;
                let address = address + 32;
            }
        }
        return;
    }


    function void draw_h_line(int x1, int y, int x2){
        var int address, end_address, mask, bit_index ;


        let address = 16384 + (x1 / 16) + (y * 32) + 1;
        let end_address = 16384 + (x2 / 16) + (y * 32) + 1;

        if(address = end_address){
            let mask = 0;
            let bit_index = x1 - ((x1 / 16) * 16);
            while(~(x1 > x2)){
                let mask = mask | Math.poweroftwo(bit_index);
                let x1 = x1 + 1;
                let bit_index = bit_index + 1;
            }
            if(color){
                do Memory.poke(address - 1, Memory.peek(address - 1) | mask);
            }
            else{
                do Memory.poke(address - 1, Memory.peek(address - 1) & ~mask);
            }
            return;
        }
        else{
            // first partial word
            let mask = 0;
            let bit_index = x1 - ((x1 / 16) * 16);
            while(bit_index < 16){
                let mask = mask | Math.poweroftwo(bit_index);
                let bit_index = bit_index + 1;
            }
            if(color){
                do Memory.poke(address - 1, Memory.peek(address - 1) | mask);
            }
            else{
                do Memory.poke(address - 1, Memory.peek(address - 1) & ~mask);
            }

            // filling whole words
            let end_address = end_address - 1;
            while(address < end_address){
                do Memory.poke(address, color);
                let address = address + 1;
            }

            // last partial word
            let mask = 0;
            let bit_index = x2 - ((x2 / 16) * 16);
            while(~(bit_index < 0)){
                let mask = mask | Math.poweroftwo(bit_index);
                let bit_index = bit_index - 1;
            }

            if(color){
                do Memory.poke(end_address, Memory.peek(end_address) | mask);
            }
            else{
                do Memory.poke(end_address, Memory.peek(end_address) & ~mask);
            }
        }
        return;
    }

    /** Draws a filled rectangle whose top left corner is (x1, y1)
     * and bottom right corner is (x2,y2), using the current color. */
    function void drawRectangle(int x1, int y1, int x2, int y2) {
        while(~(y1 > y2)){
            do Screen.draw_h_line(x1, y1, x2);
            let y1 = y1 + 1;
        }
        return;
    }
}
